\documentclass[twoside,spanish]{elsarticle}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{float}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{ulem}
\usepackage{algorithm}
\usepackage{algpseudocode}


\floatstyle{ruled}
\newfloat{algorithm}{tbp}{loa}
\providecommand{\algorithmname}{Algoritmo}
\floatname{algorithm}{\protect\algorithmname}

% specify here the journal
\journal{Curso de <<Análisis de algoritmos>>, PUJ, Bogotá, Colombia}

\begin{document}

\begin{frontmatter}

\title{Escritura Formal Basica De Un Problema\tnoteref{t1,t2}}

\tnotetext[t1]{Este documento presenta la escritura formal de un algoritmo.}

\author[lfv]{Andres Vergara Cano}

\ead{andres-vergarac@javeriana.edu.com}

\author[fdt]{Felipe Morales Espitia}

\ead{moralese.j@javeriana.edu.com}


\address[lfv]{Pontificia Universidad Javeriana, Bogotá, Colombia}

\begin{abstract}
En este documento se presenta el problema de como escribir formalmente un algoritmo en LATEX sobre como encontrar un elemento en un arreglo utilzando una combinación entre QuickSort y Busqueda Binaria con fundamento en las bases de dividir y conquistar
\end{abstract}

\begin{keyword}
algoritmo \sep escritura formal \sep secuencia \sep elemento \sep búsqueda
\end{keyword}

\end{frontmatter}

\section*{Análisis del Problema}

El objetivo de este ejercicio es diseñar un algoritmo para encontrar un elemento específico dentro de una secuencia NO ordenada de datos. Este problema puede ser abordado de manera eficiente utilizando técnicas similares a las empleadas en la búsqueda binaria o quicksort, que es un algoritmo clásico para la búsqueda en listas ordenadas.

\subsection*{Descripción del Algoritmo "QuickBinario"}

El algoritmo QuickBinario utiliza la estrategia de dividir y conquistar para buscar un elemento en una secuencia ordenada. El proceso se describe a continuación:

\begin{enumerate}
    \item \textbf{Inicialización:}
    \begin{itemize}
        \item Se definen dos índices, \texttt{left} y \texttt{right}, que marcan los límites inferior y superior del rango de búsqueda dentro del array \texttt{A}.
    \end{itemize}
    
    \item \textbf{Búsqueda:}
    \begin{itemize}
        \item Mientras el índice \texttt{left} sea menor o igual al índice \texttt{right}, se calcula el índice del punto medio de la subsecuencia actual utilizando la fórmula:
        \[
        \text{pivote} = \frac{\text{left} + \text{right}}{2}
        \]
        \item Se obtiene el valor en la posición del punto medio:
        \[
        \text{pivote} = A[\text{pivote}]
        \]
    \end{itemize}
    
    \item \textbf{Comparación:}
    \begin{itemize}
        \item Se compara el valor en el punto medio con el elemento que estamos buscando (\texttt{x}):
        \begin{itemize}
            \item Si \(\text{pivote} = x\), se retorna \texttt{pivote}, ya que el elemento ha sido encontrado.
            \item Si \(x < \text{pivote}\), se ajusta el índice \texttt{right} para buscar en la mitad inferior de la subsecuencia. La búsqueda se realiza de manera recursiva en el rango \texttt{left} a \texttt{pivote - 1}.
            \item Si \(x > \text{pivote}\), se ajusta el índice \texttt{left} para buscar en la mitad superior de la subsecuencia. La búsqueda se realiza de manera recursiva en el rango \texttt{pivote + 1} a \texttt{right}.
        \end{itemize}
    \end{itemize}
    
    \item \textbf{Resultado:}
    \begin{itemize}
        \item Si el elemento se encuentra en alguna de las llamadas recursivas, se devuelve su posición.
        \item Si el proceso termina sin encontrar el elemento (es decir, \texttt{left} supera a \texttt{right}), se retorna \texttt{-1}, indicando que el elemento no está en la secuencia.
    \end{itemize}
\end{enumerate}


\begin{algorithm}
\begin{algorithmic}[1]

\Procedure{QuickBinario}{$A, \text{left}, \text{right}, x$}
  \If{$\text{left} > \text{right}$}
    \State \Return -1 \Comment{Elemento no encontrado}
  \EndIf
  \State $\text{pivote} \gets (\text{left} + \text{right}) \div 2$
  \State $\text{pivote} \gets A[\text{pivote}]$
  \If{$\text{pivote} = x$}
    \State \Return $\text{pivote}$ \Comment{Elemento encontrado}
  \ElsIf{$x < \text{pivote}$}
    \State \Return \Call{QuickBinario}{$A, \text{left}, \text{pivote} - 1, x$}
  \Else
    \State \Return \Call{QuickBinario}{$A, \text{pivote} + 1, \text{right}, x$}
  \EndIf
\EndProcedure

\end{algorithmic}

\caption{Quick Binario.}
\end{algorithm}



\subsection*{Complejidad}

La complejidad temporal del algoritmo Quick Binario es \(O(\log n)\), donde \(n\) es el número de elementos en la secuencia. Esta eficiencia se debe a que, en cada paso, se elimina la mitad de la subsecuencia restante.

\begin{itemize}
    \item \textbf{Complejidad Temporal:} En cada iteración del algoritmo, la longitud del rango de búsqueda se reduce a la mitad. Por lo tanto, el número de iteraciones necesarias para reducir el rango a un solo elemento es proporcional al logaritmo en base 2 del número de elementos, lo que resulta en una complejidad temporal de \(O(\log n)\).
    
    \item \textbf{Teorema Maestro:} Para el algoritmo \texttt{QuickBinario}, la relación de recurrencia es:
        \[
        T(n) = T(n/2) + O(1)
        \]
        
        Donde:
        \begin{itemize}
            \item \(a\): Número de subproblemas. Aquí, \(a = 1\), ya que se busca en una mitad del array en cada paso.
            \item \(b\): Factor de reducción del tamaño del subproblema. Aquí, \(b = 2\), ya que se divide el array en dos partes.
            \item \(f(n)\): Costo de la combinación de las soluciones de los subproblemas, aquí \(f(n) = O(1)\).
        \end{itemize}

        \textbf{Cálculo de} \( \log_b a \):
        \[
        \log_b a = \log_2 1 = 0
        \]

        \textbf{Evaluación de} \( f(n) \):
        \[
        f(n) = O(1)
        \]
        \[
        n^{\log_b a} = n^0 = 1
        \]

        Comparando \( f(n) \) con \( n^{\log_b a} \):
        \begin{itemize}
            \item \textbf{Caso 1:} Si \( f(n) = O(n^c) \) con \( c < \log_b a \).
            \item \textbf{Caso 2:} Si \( f(n) = \Theta(n^{\log_b a}) \).
            \item \textbf{Caso 3:} Si \( f(n) = \Omega(n^c) \) con \( c > \log_b a \) y se cumplen ciertas condiciones.
        \end{itemize}

        En este caso:
        \[
        f(n) = O(1) \text{ y } n^{\log_b a} = 1
        \]

        Dado que \( f(n) = \Theta(1) \) es igual a \( n^{\log_b a} \), aplica el \textbf{Caso 2}.

        \textbf{Resultado del Teorema Maestro}:
        Para el \textbf{Caso 2}, la fórmula del Teorema Maestro nos da:
        \[
        T(n) = \Theta(n^{\log_b a} \log^k n)
        \]
        Dado que \( \log_b a = 0 \) y \( k = 0 \):
        \[
        T(n) = \Theta(1 \cdot \log^0 n) = \Theta(\log n)
        \]
        Por lo tanto, la complejidad del algoritmo \texttt{QuickBinario} es:
        \[
        T(n) = \Theta(\log2 n)
        \]
\end{itemize}

\section{Diseño del Problema}

El objetivo de este problema es diseñar un algoritmo para encontrar un elemento específico en una secuencia ordenada de datos utilizando la estrategia de dividir y vencer. El algoritmo a desarrollar debe ser eficiente y estar basado en la búsqueda binaria.

\begin{enumerate}
\item \emph{\uline{Entradas}}:
\begin{enumerate}
    \item $A$: Un arreglo ordenado de elementos.
    \item $left$: El índice inferior del rango de búsqueda.
    \item $right$: El índice superior del rango de búsqueda.
    \item $x$: El elemento que se desea encontrar en el arreglo.
\end{enumerate}
\item \emph{\uline{Salidas}}:
\begin{enumerate}
    \item La posición del elemento $x$ en el arreglo $A$ si el elemento se encuentra. 
    \item $-1$ si el elemento no está en el arreglo.
\end{enumerate}
\end{enumerate}

\section{Algoritmo de Solución}

El algoritmo de solución propuesto es Quick Binario, que utiliza la estrategia de dividir y vencer para encontrar un elemento en una secuencia ordenada. A continuación se describen dos enfoques para implementar este algoritmo.

\subsection{Algoritmo Recurrente}

La versión recursiva de Quick Binario se basa en la llamada recursiva para buscar en la mitad del arreglo.

\subsubsection{Invariante}

El resultado intermedio $p_{i}$ refleja el cálculo de la búsqueda en el subarreglo definido por los índices $left$ y $right$.

\begin{itemize}
    \item Se establece el caso base donde $left > right$, indicando que el elemento no está en el subarreglo.
    \item Si $x < \text{pivote}$, se realiza una llamada recursiva para buscar en la mitad inferior. Si $x > \text{pivote}$, se realiza una llamada recursiva para buscar en la mitad superior.
    \item Se encuentra el elemento $x$ o se determina que no está en el arreglo.
\end{itemize}


\subsubsection{Análisis de Complejidad}

El algoritmo recursivo Quick Binario tiene una complejidad $O(\log n)$. Cada llamada recursiva divide el rango de búsqueda a la mitad, lo que resulta en una profundidad de recursión proporcional al logaritmo en base 2 del número de elementos.

\subsection{Notas de Implementación}

Al implementar el algoritmo Quick Binario, se deben considerar las siguientes notas:
\begin{itemize}
    \item Asegurarse de que el arreglo esté ordenado antes de aplicar el algoritmo.
    \item Manejar correctamente los índices para evitar desbordamientos y errores en los límites del arreglo.
    \item La implementación recursiva puede tener problemas de stack overflow para arreglos muy grandes; en estos casos, se puede considerar una versión iterativa del algoritmo.
    \item El algoritmo debe manejar el caso cuando $left > right$ correctamente, retornando $-1$ para indicar que el elemento no está presente.
\end{itemize}

\end{document}
